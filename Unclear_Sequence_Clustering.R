library(knitr)
library(kableExtra)
library(pdftools)
library(msa)
library(ggtree)
library(ape)
library(seqinr)
library(bios2mds)
library(randomcoloR)
library(reshape)
args = commandArgs(trailingOnly = TRUE)
#Assign names to your arguments

fasta_file <- args[1]
#fasta_file <- "/Users/brycematlock/Documents/Tree_Build_Troubleshooting/M05039:44:000000000-DH4FY:1:1101:13446:4932.sequences_with_top_BLAST_hits.fasta"
  
ideal_cluster_dataframe <- args[2]
#ideal_cluster_dataframe <- "/Users/brycematlock/Documents/Tree_Build_Troubleshooting/M05039:44:000000000-DH4FY:1:1101:13446:4932.Ideal_Cluster_Table.csv"
  
final_clustered_tree <- args[3]
#final_clustered_tree <- "/Users/brycematlock/Documents/Tree_Build_Troubleshooting/Ideal_cluster_Tree_Practice.pdf"

##Set a variable for your fasta file

updx <- readDNAStringSet(fasta_file, format="fasta", use.names = TRUE)

##Perform multiple sequence alignment 

updx_align <- msaClustalOmega(updx)

##Convert output to align object 

aln <- msaConvert(updx_align, type="seqinr::alignment")

##Export align object to fasta to check alignment in geneious

#export.fasta(aln, outfile = "/Users/brycematlock/Documents/Cryptosporidium_Workflow_Alignment.fasta")

##Convert align object into a distance alignment

d <- dist.alignment(aln, matrix = c("identity"), gap = 1)


##Convert distance alignment to distance matrix

updx_mat <- as.matrix(d)

##Perform Agglomerative hierarchical clustering on distance matrix and convert that to a as.hclust object

updx_mat_x <- as.hclust(agnes(x=updx_mat, diss = TRUE, method = "ward"))


##Convert distance matrix into a tree

updx_tree <- as.phylo(updx_mat_x)

#Write the tree as circular for ease of interpretation

cir_updx_tree <- ggtree(updx_tree, size = 0.6, layout = "circular")

#Add specimen/sequence names to the tips of the tree

tip_updx_tree <- cir_updx_tree + geom_tiplab2(color = "black", size = 2.0, offset = -0.005) + hexpand(.9)

#Create vector for increasing heights to cut the tree

max_height <- max(updx_mat_x$height)
min_height <- min(updx_mat_x$height)
height_dividend <- (max_height/20)
heights <- seq(from = max_height, to = min_height, by = -height_dividend)
pick_min_cluster_number <- c()


##Create a dataframe that keeps track of the tip labes for the tree

tip_labels <- data.frame(updx_tree$tip.label)
tip_labels <- cbind(rownames(tip_labels), tip_labels)
colnames(tip_labels) <- c("Tips", "Specimen")

#Create loop for cutting the trees at increasing heights
for (h in 1:length(heights)) {
  cluster <- as.data.frame(melt(factor(cutree(updx_mat_x, h = heights[h]))))
  
  #Add a column called rownames(cluster) to the dataframe created by cutree
  cluster_good <- cbind(rownames(cluster), cluster)
  
  #Create column names for dataframe (Seq_ID for the column you just added and Cluster for the cluster number generated by Cutree)
  colnames(cluster_good) <- c("Seq_ID", "Cluster")
  
  #Remove the row names column 
  rownames(cluster_good) <- NULL
  
  #Add another column for cluster name that corresponds to the Cluster column in the dataframe
  cluster_good <- cbind(cluster_good, paste0("Cluster_",cluster_good$Cluster,"_"))
  
  #Change the name of the new column
  colnames(cluster_good) <- c("Seq_ID","Cluster","Cluster_name")
  
  #Sort the dataframe based on the Cluster column
  cluster_good <- cluster_good[order(cluster_good$Cluster),]
  
  #Create variable that lists the number of clusters currently in dataframe
  number_of_clusters <- max(as.numeric(cluster$value))
  
  #Split the newly created dataframe into multiple dataframes for each cluster
  cluster_splits <- split(cluster_good, cluster_good$Cluster_name)
  Stop <- FALSE
  
  #Loop through each dataframe until you find the one that contains our sample sequence and save that dataframe
  for(i in seq_along(cluster_splits)){
    ifelse (stringr::str_detect(cluster_splits[[i]]$Seq_ID, "^M") == TRUE, foobar <- print(cluster_splits[[i]]), next)
    
    #If the dataframe only contains our sample sequence with no other sequences break the entire loop pick the height
    #right before and cut at that height and save the cluster that contains our sample sequence  
    if (length(foobar$Seq_ID == 1)){
      Stop <- TRUE
      min_height_to_pick <- (print(heights[h-2]))
      ideal_cluster_cut <- as.data.frame(melt(factor(cutree(updx_mat_x, h = min_height_to_pick))))
      ideal_cluster_good <- cbind(rownames(ideal_cluster_cut), ideal_cluster_cut)
      colnames(ideal_cluster_good) <- c("Seq_ID", "Cluster")
      rownames(ideal_cluster_good) <- NULL
      ideal_cluster_good <- cbind(ideal_cluster_good, paste0("Cluster_",ideal_cluster_good$Cluster,"_"))
      colnames(ideal_cluster_good) <- c("Seq_ID", "Cluster", "Cluster_name")
      ideal_cluster_good <- ideal_cluster_good[order(ideal_cluster_good$Cluster),]
      ideal_cluster_splits <- split(ideal_cluster_good, ideal_cluster_good$Cluster_name)
      for (j in seq_along(ideal_cluster_splits)) {
        ifelse (stringr::str_detect(ideal_cluster_splits[[j]]$Seq_ID, "^M") == TRUE, ideal_cluster <- print(ideal_cluster_splits[[j]]), next)
      }
#If the dataframe contains our sample sequences with other sequences continue the loop and cut at the next height
    } else {
      Stop <- FALSE
      next
    }
    if (Stop == TRUE){break}
  }
  if (Stop == TRUE){break}
}

if (Stop == FALSE){
  ideal_cluster_good <- foobar
  ideal_cluster <- foobar
}


##Find the ideal cluster in the tree and highlight it

sample_cluster <- ideal_cluster[1,3]
tip_with_cluster_labels <- merge(ideal_cluster_good, tip_labels, by.x = "Seq_ID", by.y = "Specimen", all.x = FALSE, all.y = FALSE)
mySamples <- as.numeric(tip_with_cluster_labels[grepl(sample_cluster, tip_with_cluster_labels[,3]), 4])

##Create a vector that stores random colors to highlight the samples in the tree

sampleCols <- vector()
for (i in 1:length(mySamples)) {
  myCol <- randomColor()
  sampleCols <- c(sampleCols, myCol)
}

for (k in 1:length(mySamples)) {
  color_of_strips <- sampleCols[k]
  final_updx_tree <- tip_updx_tree + geom_highlight(node = c(mySamples), fill = color_of_strips, extend = 0.95, alpha = 0.5)
}

#Save final_updx_tree to pdf file
ggsave(final_updx_tree, file = final_clustered_tree, width = 50, height = 50, units = "cm", limitsize = FALSE)

#Write ideal cluster to csv file
write.csv(ideal_cluster, file = ideal_cluster_dataframe)